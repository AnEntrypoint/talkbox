<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Talkbox - Secure Message Exchange</title>
  <script src="nacl-fast.min.js"></script>
  <script src="qrcode.min.js"></script>
  <script src="jsqr.js"></script>
  <script src="nostr-tools.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
    .container { max-width: 600px; margin: 0 auto; background: white; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.2); padding: 40px; }
    .header { margin-bottom: 40px; border-bottom: 3px solid #667eea; padding-bottom: 24px; }
    .header h1 { font-size: 36px; background: linear-gradient(135deg, #667eea, #764ba2); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 12px; font-weight: 700; }
    .header p { color: #666; font-size: 15px; line-height: 1.7; }
    .tabs { display: flex; gap: 0; margin-bottom: 32px; border-bottom: 2px solid #eee; overflow-x: auto; }
    .tab { padding: 14px 24px; border: none; background: none; cursor: pointer; font-size: 14px; font-weight: 600; color: #999; border-bottom: 3px solid transparent; margin-bottom: -2px; transition: all 0.2s; white-space: nowrap; }
    .tab:hover { color: #667eea; }
    .tab.active { color: #667eea; border-color: #667eea; }
    .tab-content { display: none; }
    .tab-content.active { display: block; animation: fadeIn 0.2s; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    .form-group { margin-bottom: 24px; }
    label { display: block; font-size: 13px; font-weight: 700; color: #333; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
    input[type="text"], input[type="password"], textarea { width: 100%; padding: 12px 14px; border: 2px solid #eee; border-radius: 6px; font-size: 14px; font-family: monospace; transition: all 0.2s; background: #f9f9f9; }
    input[type="text"]:focus, input[type="password"]:focus, textarea:focus { outline: none; border-color: #667eea; background: white; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1); }
    textarea { resize: vertical; min-height: 100px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
    button { width: 100%; padding: 14px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3); }
    button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4); }
    button:active { transform: translateY(0); }
    button.small { width: auto; padding: 8px 14px; font-size: 12px; margin-left: 8px; display: inline-block; background: #667eea; box-shadow: none; }
    .result { padding: 18px; border-radius: 8px; margin-top: 24px; font-size: 14px; border-left: 4px solid #667eea; background: #f0f4ff; color: #667eea; }
    .result.success { border-left-color: #28a745; background: #d4edda; color: #155724; }
    .result.error { border-left-color: #dc3545; background: #f8d7da; color: #721c24; }
    .result h3 { font-size: 15px; margin-bottom: 10px; font-weight: 700; }
    .shortcode-display { font-family: monospace; font-size: 16px; font-weight: bold; color: #667eea; padding: 16px; background: #f0f4ff; border-radius: 6px; word-break: break-all; margin: 16px 0; text-align: center; border: 2px solid #e0e7ff; }
    .message-item { background: linear-gradient(135deg, #f9f9f9, #f0f4ff); padding: 14px; margin-bottom: 14px; border-radius: 6px; border-left: 4px solid #667eea; }
    .message-text { color: #333; font-size: 14px; word-break: break-word; margin-bottom: 8px; line-height: 1.6; }
    .message-time { color: #999; font-size: 12px; }
    .info { background: linear-gradient(135deg, #e3f2fd, #f0f4ff); color: #1565c0; padding: 14px; border-radius: 6px; margin-bottom: 24px; font-size: 14px; line-height: 1.6; border-left: 4px solid #667eea; }
    .shortcode-container { display: flex; gap: 16px; align-items: flex-start; }
    .shortcode-visual { display: grid; grid-template-columns: repeat(16, 1fr); gap: 2px; padding: 12px; background: white; border-radius: 6px; border: 2px solid #eee; }
    .shortcode-visual.compact { grid-template-columns: repeat(8, 1fr); }
    .pixel { width: 8px; height: 8px; border-radius: 1px; }
    .shortcode-text-compact { font-family: monospace; font-size: 12px; color: #667eea; word-break: break-all; line-height: 1.6; }
    @media (max-width: 600px) {
      .container { padding: 24px; }
      .header h1 { font-size: 28px; }
      .shortcode-container { flex-direction: column; }
      button.small { width: 100%; margin-left: 0; margin-top: 8px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Talkbox</h1>
      <p>Send encrypted messages using public key cryptography. Only the recipient can read messages.</p>
    </div>

    <div class="tabs">
      <button class="tab active" onclick="switchTab('generate')">1. Generate</button>
      <button class="tab" onclick="switchTab('send')">2. Send</button>
      <button class="tab" onclick="switchTab('read')">3. Read</button>
    </div>

    <!-- Generate Tab -->
    <div id="generate" class="tab-content active">
      <div class="info">
        <strong>Step 1:</strong> Create a password. Your shortcode is derived from it instantly (100% client-side, no server interaction).
      </div>
      <div class="form-group">
        <label for="gen-password">Your Password</label>
        <input type="password" id="gen-password" placeholder="Make it strong" onkeyup="liveGenerateShortcode()">
      </div>
      <div id="gen-result"></div>
    </div>

    <!-- Send Tab -->
    <div id="send" class="tab-content">
      <div class="info">
        <strong>Step 2:</strong> Someone shares their shortcode. Send them an encrypted message (only they can read it with their password).
      </div>
      <div class="form-group">
        <label for="send-shortcode">Their Shortcode</label>
        <input type="text" id="send-shortcode" placeholder="Paste the shortcode they shared or scan QR">
        <button class="small" onclick="toggleQRScanner()">ðŸ“± Scan QR</button>
      </div>
      <div id="scanner-container" style="display: none; margin-bottom: 20px;">
        <video id="qr-video" autoplay playsinline muted style="width: 100%; border-radius: 4px; margin-bottom: 10px;"></video>
        <button onclick="stopQRScanner()" style="width: 100%;">Stop Scanner</button>
      </div>
      <div class="form-group">
        <label for="send-message">Your Message</label>
        <textarea id="send-message" placeholder="What do you want to say?"></textarea>
      </div>
      <button onclick="sendMessage()">Send Message</button>
      <div id="send-result"></div>
    </div>

    <!-- Read Tab -->
    <div id="read" class="tab-content">
      <div class="info">
        <strong>Step 3:</strong> Enter your password to read all messages sent to you.
      </div>
      <div class="form-group">
        <label for="read-password">Your Password</label>
        <input type="password" id="read-password" placeholder="Your password" onkeyup="liveShowShortcode()">
      </div>
      <button onclick="readMessages()">Read Messages</button>
      <div id="read-result"></div>
    </div>
  </div>

  <script>
    console.log('Talkbox - 100% client-side, no backend needed');

    const RELAYS = [
      'wss://relay.damus.io',
      'wss://nos.lol',
      'wss://nostr.wine',
      'wss://relay.nostr.band',
      'wss://nostr-pub.wellorder.net',
      'wss://relay.snort.social',
      'wss://nostr.mom',
      'wss://relay.current.fyi'
    ];

    function switchTab(tab) {
      document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
      document.querySelectorAll('.tab').forEach(el => el.classList.remove('active'));
      document.getElementById(tab).classList.add('active');
      event.target.classList.add('active');
    }

    function toBase58(bytes) {
      const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
      let num = 0n;
      for (let i = 0; i < bytes.length; i++) {
        num = num * 256n + BigInt(bytes[i]);
      }
      if (num === 0n) return '1';
      let result = '';
      while (num > 0n) {
        result = alphabet[Number(num % 58n)] + result;
        num = num / 58n;
      }
      for (let i = 0; i < bytes.length; i++) {
        if (bytes[i] === 0) result = '1' + result;
        else break;
      }
      return result;
    }

    function fromBase58(str) {
      const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
      let num = 0n;
      for (let i = 0; i < str.length; i++) {
        const idx = alphabet.indexOf(str[i]);
        if (idx === -1) throw new Error('Invalid Base58 character');
        num = num * 58n + BigInt(idx);
      }
      const bytes = [];
      while (num > 0n) {
        bytes.unshift(Number(num & 0xFFn));
        num = num >> 8n;
      }
      for (let i = 0; i < str.length; i++) {
        if (str[i] === '1') bytes.unshift(0);
        else break;
      }
      return new Uint8Array(bytes.length === 0 ? [0] : bytes);
    }

    function generateVisualGrid(bytes, compact = true) {
      const cols = compact ? 8 : 16;
      const html = [];
      for (let i = 0; i < (compact ? 8 : 32); i++) {
        for (let j = 0; j < 8; j++) {
          const bit = (bytes[i] >> (7 - j)) & 1;
          html.push(`<div class="pixel" style="background: ${bit ? '#007bff' : '#f0f0f0'}"></div>`);
        }
      }
      return html.join('');
    }

    function createQRCode(secretKeyBytes, base58Text) {
      try {
        const container = document.createElement('div');
        const base64 = btoa(String.fromCharCode.apply(null, secretKeyBytes));
        const qr = new QRCode(container, {
          text: base64,
          width: 120,
          height: 120,
          colorDark: '#000000',
          colorLight: '#ffffff',
          correctLevel: QRCode.CorrectLevel.L
        });

        const canvas = container.querySelector('canvas');
        if (canvas) {
          return {
            dataUrl: canvas.toDataURL('image/png'),
            compact: base58Text,
            full: base58Text,
            bytes: secretKeyBytes
          };
        }

        const img = container.querySelector('img');
        if (img) {
          return {
            dataUrl: img.src,
            compact: base58Text,
            full: base58Text,
            bytes: secretKeyBytes
          };
        }

        return null;
      } catch (e) {
        console.warn('QR generation failed:', e);
        return null;
      }
    }

    async function generateShortcodeFromPassword(password) {
      if (!password) return { hex: '', base58: '', visual: '', qr: null };
      if (!window.nostrTools) {
        console.error('nostr-tools not loaded');
        return { hex: '', base58: '', visual: '', qr: null };
      }

      // Derive Nostr Ed25519 public key from password
      const encoder = new TextEncoder();
      const data = encoder.encode(password + 'talkbox-nostr-derivation');
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const seed = new Uint8Array(hashBuffer);
      const secretKey = seed.slice(0, 32);
      const publicKey = window.nostrTools.getPublicKey(secretKey);

      const base58 = toBase58(secretKey);
      const visual = generateVisualGrid(secretKey, true);
      const qrData = createQRCode(secretKey, base58);

      return { hex: publicKey, base58, visual, qr: qrData, bytes: secretKey };
    }

    async function deriveKeypair(password) {
      // For encryption, use NaCl with hash as seed
      const encoder = new TextEncoder();
      const data = encoder.encode(password);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const seed = new Uint8Array(hashBuffer);
      const keypair = nacl.box.keyPair.fromSecretKey(seed.slice(0, 32));
      return keypair;
    }

    async function liveGenerateShortcode() {
      const password = document.getElementById('gen-password').value;
      if (!password) {
        document.getElementById('gen-result').innerHTML = '';
        return;
      }
      const result = await generateShortcodeFromPassword(password);
      const qrImg = result.qr && result.qr.dataUrl ? `<img src="${result.qr.dataUrl}" style="max-width: 120px; border: 1px solid #ddd; border-radius: 4px;" alt="MicroQR" title="Compact MicroQR format"/>` : '';
      const html = `
        <div class="result success">
          <h3>âœ“ Your Shortcode (Generated Instantly)</h3>
          <div style="display: flex; gap: 20px; align-items: flex-start;">
            <div style="text-align: center;">
              ${qrImg}
              <div style="font-size: 10px; color: #999; margin-top: 8px;">QR Code<br>(raw 32 bytes)</div>
            </div>
            <div style="flex: 1;">
              <div class="shortcode-text-compact" style="margin-bottom: 8px;"><strong>Share this Base58:</strong><br>${result.base58}</div>
              <button class="small" onclick="copyToClipboard('${result.base58}')">Copy Base58</button>
            </div>
          </div>
          <span style="color: #666; font-size: 12px; margin-top: 12px; display: block;">ðŸ“± QR Code encodes raw 32-byte key (MicroQR max is 15 bytes). Scan with camera to auto-fill shortcode.</span>
        </div>
      `;
      document.getElementById('gen-result').innerHTML = html;
    }

    async function liveShowShortcode() {
      const password = document.getElementById('read-password').value;
      if (!password) return;
      const shortcode = await generateShortcodeFromPassword(password);
      console.log('Your shortcode:', shortcode);
    }

    async function sendMessage() {
      let shortcodeInput = document.getElementById('send-shortcode').value.trim();
      const message = document.getElementById('send-message').value;
      if (!shortcodeInput || !message) {
        showResult('send-result', 'Please enter shortcode and message', 'error');
        return;
      }
      try {
        showResult('send-result', 'Publishing to Nostr relays...', 'success');

        const pool = new window.nostrTools.SimplePool();

        const senderPassword = 'talkbox-sender-' + Math.random();
        const senderSecret = await deriveSecret(senderPassword);
        const senderPubkey = window.nostrTools.getPublicKey(senderSecret);

        let recipientSecretBytes;
        if (shortcodeInput.length === 32 && /[\x00-\x1F\x7F-\xFF]/.test(shortcodeInput)) {
          recipientSecretBytes = new Uint8Array(shortcodeInput.split('').map(c => c.charCodeAt(0)));
        } else {
          try {
            recipientSecretBytes = fromBase58(shortcodeInput);
          } catch (e) {
            showResult('send-result', 'Invalid shortcode format', 'error');
            return;
          }
        }
        if (!recipientSecretBytes || recipientSecretBytes.length !== 32) {
          showResult('send-result', 'Invalid shortcode format', 'error');
          return;
        }
        const recipientPubkey = window.nostrTools.getPublicKey(recipientSecretBytes);

        const event = window.nostrTools.finalizeEvent({
          kind: 1,
          created_at: Math.floor(Date.now() / 1000),
          tags: [['p', recipientPubkey]],
          content: message,
          pubkey: senderPubkey
        }, senderSecret);

        const publishPromises = RELAYS.map(async r => {
          try {
            const pubs = pool.publish([r], event);
            let published = false;
            for await (const pub of pubs) {
              published = true;
            }
            return published;
          } catch (e) {
            console.error('Publish error:', e);
            return false;
          }
        });

        const results = await Promise.all(publishPromises);
        await new Promise(r => setTimeout(r, 500));
        pool.close(RELAYS);

        document.getElementById('send-message').value = '';
        showResult('send-result', 'âœ“ Message sent successfully!', 'success');
      } catch (e) {
        showResult('send-result', 'Error: ' + e.message, 'error');
      }
    }

    async function deriveSecret(password) {
      const encoder = new TextEncoder();
      const data = encoder.encode(password + 'talkbox-nostr-derivation');
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      return new Uint8Array(hashBuffer).slice(0, 32);
    }

    async function readMessages() {
      const password = document.getElementById('read-password').value;
      if (!password) {
        showResult('read-result', 'Please enter your password', 'error');
        return;
      }
      try {
        showResult('read-result', 'Querying Nostr relays...', 'success');

        const result = await generateShortcodeFromPassword(password);
        const shortcode = result.hex;
        const pool = new window.nostrTools.SimplePool();

        const filter = {
          kinds: [1],
          '#p': [shortcode],
          limit: 100
        };

        const events = await pool.querySync(RELAYS, filter, { timeout: 5000 });
        pool.close(RELAYS);

        const messages = events
          .sort((a, b) => b.created_at - a.created_at)
          .map(e => ({
            message: e.content,
            timestamp: e.created_at * 1000
          }));

        if (messages.length === 0) {
          const qrImg = result.qr && result.qr.dataUrl ? `<img src="${result.qr.dataUrl}" style="max-width: 100px; border: 1px solid #ddd; border-radius: 4px;" alt="QR Code"/>` : '';
          showResult('read-result', `<h3>No messages yet</h3><strong>Your shortcode to share:</strong><div style="margin-top: 12px; display: flex; gap: 12px;"><div style="text-align: center;">${qrImg}</div><div><div class="shortcode-text-compact"><strong>Base58:</strong><br>${result.base58}</div></div></div>`, 'success');
        } else {
          let html = `<h3>ðŸ“¨ Messages (${messages.length})</h3>`;
          messages.forEach(msg => {
            const time = new Date(msg.timestamp).toLocaleString();
            html += `<div class="message-item"><div class="message-text">${escapeHtml(msg.message)}</div><div class="message-time">${time}</div></div>`;
          });
          document.getElementById('read-result').innerHTML = `<div class="result success">${html}</div>`;
        }
      } catch (e) {
        showResult('read-result', 'Error: ' + e.message, 'error');
      }
    }

    function showResult(elementId, message, type) {
      const resultDiv = document.getElementById(elementId);
      resultDiv.innerHTML = `<div class="result ${type}"><h3>${type === 'error' ? 'âš ' : 'âœ“'}</h3>${message}</div>`;
    }

    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        alert('Copied!');
      });
    }

    function escapeHtml(text) {
      const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
      return text.replace(/[&<>"']/g, m => map[m]);
    }

    let scannerStream = null;

    async function toggleQRScanner() {
      const container = document.getElementById('scanner-container');
      if (container.style.display === 'none') {
        await startQRScanner();
        container.style.display = 'block';
      } else {
        stopQRScanner();
        container.style.display = 'none';
      }
    }

    async function startQRScanner() {
      const video = document.getElementById('qr-video');
      try {
        scannerStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }
        });
        video.srcObject = scannerStream;
        await video.play();
        scanQRFrame(video);
      } catch (e) {
        console.error('Camera error:', e.name, e.message);
        const msg = e.name === 'NotAllowedError'
          ? 'Camera permission denied. Allow camera access in browser settings.'
          : e.name === 'NotFoundError'
          ? 'No camera found on this device.'
          : 'Camera error: ' + e.message;
        showResult('send-result', msg, 'error');
      }
    }

    function stopQRScanner() {
      document.getElementById('scanner-container').style.display = 'none';
      if (scannerStream) {
        scannerStream.getTracks().forEach(track => track.stop());
        scannerStream = null;
      }
    }

    function scanQRFrame(video) {
      if (!scannerStream) return;

      if (!video.videoWidth || !video.videoHeight) {
        requestAnimationFrame(() => scanQRFrame(video));
        return;
      }

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      ctx.drawImage(video, 0, 0);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const code = jsQR(imageData.data, canvas.width, canvas.height);

      if (code) {
        try {
          const bytes = Uint8Array.from(atob(code.data), c => c.charCodeAt(0));
          const shortcode = toBase58(bytes);
          document.getElementById('send-shortcode').value = shortcode;
          stopQRScanner();
          showResult('send-result', 'âœ“ QR code scanned successfully!', 'success');
        } catch (e) {
          showResult('send-result', 'Invalid QR code data', 'error');
        }
      } else {
        requestAnimationFrame(() => scanQRFrame(video));
      }
    }

  </script>
</body>
</html>
